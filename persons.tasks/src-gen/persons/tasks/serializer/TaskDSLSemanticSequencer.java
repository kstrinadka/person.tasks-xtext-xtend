/*
 * generated by Xtext 2.32.0
 */
package persons.tasks.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import persons.tasks.services.TaskDSLGrammarAccess;
import persons.tasks.taskDSL.Duration;
import persons.tasks.taskDSL.LunchAction;
import persons.tasks.taskDSL.MeetingAction;
import persons.tasks.taskDSL.PaperAction;
import persons.tasks.taskDSL.PaymentAction;
import persons.tasks.taskDSL.Person;
import persons.tasks.taskDSL.Planning;
import persons.tasks.taskDSL.Task;
import persons.tasks.taskDSL.TaskDSLPackage;

@SuppressWarnings("all")
public class TaskDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TaskDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TaskDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TaskDSLPackage.DURATION:
				sequence_Duration(context, (Duration) semanticObject); 
				return; 
			case TaskDSLPackage.LUNCH_ACTION:
				sequence_LunchAction(context, (LunchAction) semanticObject); 
				return; 
			case TaskDSLPackage.MEETING_ACTION:
				sequence_MeetingAction(context, (MeetingAction) semanticObject); 
				return; 
			case TaskDSLPackage.PAPER_ACTION:
				sequence_PaperAction(context, (PaperAction) semanticObject); 
				return; 
			case TaskDSLPackage.PAYMENT_ACTION:
				sequence_PaymentAction(context, (PaymentAction) semanticObject); 
				return; 
			case TaskDSLPackage.PERSON:
				sequence_Person(context, (Person) semanticObject); 
				return; 
			case TaskDSLPackage.PLANNING:
				sequence_Planning(context, (Planning) semanticObject); 
				return; 
			case TaskDSLPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Duration returns Duration
	 *
	 * Constraint:
	 *     (dl=INT unit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_Duration(ISerializationContext context, Duration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TaskDSLPackage.Literals.DURATION__DL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TaskDSLPackage.Literals.DURATION__DL));
			if (transientValues.isValueTransient(semanticObject, TaskDSLPackage.Literals.DURATION__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TaskDSLPackage.Literals.DURATION__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDurationAccess().getDlINTTerminalRuleCall_0_0(), semanticObject.getDl());
		feeder.accept(grammarAccess.getDurationAccess().getUnitTimeUnitEnumRuleCall_1_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns LunchAction
	 *     LunchAction returns LunchAction
	 *
	 * Constraint:
	 *     location=ID
	 * </pre>
	 */
	protected void sequence_LunchAction(ISerializationContext context, LunchAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TaskDSLPackage.Literals.LUNCH_ACTION__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TaskDSLPackage.Literals.LUNCH_ACTION__LOCATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLunchActionAccess().getLocationIDTerminalRuleCall_1_0(), semanticObject.getLocation());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns MeetingAction
	 *     MeetingAction returns MeetingAction
	 *
	 * Constraint:
	 *     topic=STRING
	 * </pre>
	 */
	protected void sequence_MeetingAction(ISerializationContext context, MeetingAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TaskDSLPackage.Literals.MEETING_ACTION__TOPIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TaskDSLPackage.Literals.MEETING_ACTION__TOPIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMeetingActionAccess().getTopicSTRINGTerminalRuleCall_1_0(), semanticObject.getTopic());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns PaperAction
	 *     PaperAction returns PaperAction
	 *
	 * Constraint:
	 *     report=ID
	 * </pre>
	 */
	protected void sequence_PaperAction(ISerializationContext context, PaperAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TaskDSLPackage.Literals.PAPER_ACTION__REPORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TaskDSLPackage.Literals.PAPER_ACTION__REPORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPaperActionAccess().getReportIDTerminalRuleCall_1_0(), semanticObject.getReport());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Action returns PaymentAction
	 *     PaymentAction returns PaymentAction
	 *
	 * Constraint:
	 *     amount=INT
	 * </pre>
	 */
	protected void sequence_PaymentAction(ISerializationContext context, PaymentAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TaskDSLPackage.Literals.PAYMENT_ACTION__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TaskDSLPackage.Literals.PAYMENT_ACTION__AMOUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPaymentActionAccess().getAmountINTTerminalRuleCall_1_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Person returns Person
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Person(ISerializationContext context, Person semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TaskDSLPackage.Literals.PERSON__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TaskDSLPackage.Literals.PERSON__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPersonAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Planning returns Planning
	 *
	 * Constraint:
	 *     (name=ID (persons+=Person | tasks+=Task)*)
	 * </pre>
	 */
	protected void sequence_Planning(ISerializationContext context, Planning semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (action=Action persons+=[Person|ID]+ prio=INT duration=Duration?)
	 * </pre>
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
